#
# Schema Definition and Documentation
#
# This file is the source of truth for the schema in use. It can be used to
# generate the glossary, documentation, and the description of validation
# errors.
#
#
# This enables verbose error messages. Given some CLI app (called `app`), we
# want to be able to explain errors in detail such as:
#
#   $ app parse --verbose
#   Parsing Error: constraint 'foo' is not a dict
#
#   A constraint is used to restrict the range of valid choices for a setting.
#   A constraint can be supplied in two formats; long form and shorthand. The
#   shorthand format exists to simplify writing blueprints by support simple
#   `setting: value` entries such as `os: Ubuntu 14.04`.
#
#   The long form requires explicit key/value pairs in the format:
#     setting: <name>
#     <condition>: <value>
#     message: <optional error message>
#   In YAML, this would look like:
#     constraints:
#     - setting: os
#       value: Ubuntu 14.04
#       message: This app only works on Ubuntu 14.04!
#     - setting: memory
#       greater-than-or-equal-to: 1Gb
#
#   Supported conditions are:
#
#   * `greater-than`: self-explanatory (for strings or integers)
#   * `less-than`: self-explanatory (for strings or integers)
#   * `greater-than-or-equal-to`: self-explanatory (for strings or integers)
#   * `less-than-or-equal-to`: self-explanatory (for strings or integers)
#   * `min-length`: for strings or text
#   * `max-length`: for strings or text (including URLs)
#   * `allowed-chars`: for strings and text types. Ex. "ABCDEFGabcdefg012345657!&@"
#   * `required-chars`: for strings and text types. Ex. "ABCDEFG"
#   * `in`: a list of acceptable values (these could also be used by clients to
#     display drop-downs)
#   * `protocols`: unique to URL types. This lists allowed protocols in the URL.
#     See also display-hints for `encrypted-protocols`
#   * `regex`: do not use look-forward/behind. Keep these simple so they are
#     supported in javascript (client) and python (server). While many of the above
#     can also be written as regex rules, both are available to blueprint authors
#     to use the one that suits them best.
#   * `check`: evaluates a constraint using constructs like "if", "if-not",
#     "and", etc...
#   $
#

blueprint:
  description: 'A model describing an application topology'
  docs: |
    A blueprint is a description of an application, the definitions of its
    components, their relations to other services that they support or require, and
    how they all connect. It can also contain one or more topologies describing
    different architectural configurations for the application.

    A blueprint has a data schema and may be stored as a file, in memory, or in a
    database.

  fields:
    id:
      type: string  # not necessarily a UUID
      description: "A unique string to store, lookup and manipulate a blueprint"
    name:
    version:
      description: semver number for your use
    description:
    source:
      type: source
    metadata:
      type: dict
    services:
     type: dict(service)
     docs: |
      * What is inside the boxes (web, database, application, cache)
      * These components have sane defaults set
      * Custom components are possible

      An example component, under the `appserver` service:

      * type: Describes the component based on a list of primitives (compute,
        application, database, load-balancer)
      * name: Arbitrary name for the the component.
      * role: Role of the component
      * relations: How this component connects to others in the blueprint.
      * constraints: Optional constraints applied at the provider level (ex.
        region=DFW).

      ```yaml
      appserver:
        component:
          type: application
          name: django
          role: app_srvr
          relations:
            backend: mysql
          constraints:
            - omnibus-version: "11.8.2"
      ```

    relations:
      type: list(relation)
    options:
      type: dict(option)
      docs: |
        Options are choices which the blueprint wants to present to the user launching a
        deployment. The blueprint author determines where the value of that option is
        applied in the blueprint.

        Options are like variables which can be defined once and used many times in the
        blueprint. For example: A URL can be used both to define an Apache vhost as well
        as to determine the protocol of a load balancer.

        Options can be defined as  can have a default value which is used if no
        corresponding [input](#inputs) is provided. If a "required" option has no
        default value and no corresponding input, the deployment cannot be launched.

        Options are defined in the `options` section of a blueprint.

        Choices presented to the user launching the deployment. The options will most
        likely be the bulk of the Checkmatefile.

        * OS, memory, flavor, disk, domain, etc.

        An example options section, with several types (choice, constrains,
        constraints):

        ```yaml
        options:
          region:
            label: Region
            type: string
            required: true
            default: DFW
            display-hints:
              group: deployment
              list-type: region
              choice:
                - DFW
                - ORD
                - LON
                - SYD
                - IAD
                constrains:
                  - setting: region
          server_count:
            label: Server Count
            type: integer
            required: true
            default: 2
            display-hints:
              group: server
              order: 1
              constraints:
                - greater-than-or-equal-to: 1
                message: must build at least one server
                - less-than-or-equal-to: 25
                message: maximum of 25 allowed
                constrains:
                  - setting: count
                  service: appserver
                  resource_type: application
          os:
            label: Operating System
            type: string
            default: Ubuntu 12.04
            display-hints:
              group: server
              order: 2
              list-type: compute.os
              choice:
              - name: Ubuntu 12.04 LTS (Precise Pangolin)
              value: Ubuntu 12.04
              - name: CentOS 6.5
              value: CentOS 6.5
              constraints:
              - in: ["Ubuntu 12.04", "CentOS 6.5"]
            constrains:
            - setting: os
            resource_type: compute
            service: appserver
        ```

        ###### Passwords

        When creating an option for a password, several values are available:

        **default**: The default value to use. YAML will assume numbers are ints, so
        enclose strings in "quotation marks" as a best practice. Special values for this
        are `=generate_password()` which will generate a random password on the server.
        Several parameters can be passed to `generate_password()`:

        - `min_length=<integer>`: a number representing the minimum number of characters
          in the password. If `max_length` is not specified the password will be
          `min_length` characters.
        - `max_length=<integer>`: a number representing the maximum number of characters
          in the password. If `min_length` is not also specified the password will be
          `max_length` characters. If both `min_length` and `max_length` are specified
          the password length will be chosen at random from the specified range.  The
          maximum length allowed is 255 characters.
        - `required_chars=["<string1>", "<string2>", ..."<stringN>"]`: the generated
          password will contain one character from each string in the set. A string can
          be duplicated to require more than one character from the same set.
        - `starts_with="<string>"`: for use when the first password character should be
          restricted to a set of characters. Defaults to all alphanumeric characters.
          Pass `starts_with=None` to override this behavior.
        - `valid_chars`: the set of characters that should be used for all but
          `starts_with` and `required_chars` chars. `valid_chars` can contain duplicates
          of the characters specified in both `starts_with` and `required_chars`.
          Defaults to all alphanumeric characters.

        Here is an example password option:

        ```yaml
        options:
          password:
            label: Admin Password
            type: password
            description: Password to use to administer your deployment.
            default: '=generate_password(min_length=6, required_chars=["0123456789", "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"])'
            constraints:
            - regex: '^(?=.*).{6,15}$'
              message: must be between 6 and 15 characters long
            - regex: '^(?=.*\d)'
              message: must contain a digit
            - regex: '^(?=.*[a-z])'
              message: must contain a lower case letter
            - regex: '^(?=.*[A-Z])'
              message: must contain an upper case letter
        ```

        ###### URLs

        Options of type url provide some advanced handling of common url use cases. The
        option can be used simply as a string that accepts a url. In this case, the only
        benefit of setting the type to url is that a client application can perform
        certain validation to make sure the provided value is a valid URL (according to
        [RFC 3986](http://tools.ietf.org/html/rfc3986)). Example:

        ```yaml
        option:
          my_web_site:
            type: url
        ```

        It is useful, however, to be able to handle different parts of a URL (i.e the
        scheme or protocol, domain, path, port, username, password, etc...) separately.
        They may be validated independently (e.g. make sure the protocol is http or
        https only). The parts may be wired up to different parts of the blueprint using
        constraints (e.g. use the domain part for a dns setting). The way that is
        supported is that the url type has attributes that can be accessed in the
        Checkmatefile or other parts of Checkmate. These attributes are:

        * scheme: this is the first part of the URL
        * protocol: this is the first part of the URL as well (an alias to scheme)
        * netloc: the dns name or address part
        * port: this is the port if specified (e.g. the port in http://localhost:8080 is
          8080)
        * path: the path of the resource or file
        * private_key: the private_key of a certificate to use if the protocol is an
          encrypted one
        * certificate: the public_key of a certificate to use if the protocol is an
          encrypted one
        * intermediate_key: the intermediate key chain of a certificate to use if the
          protocol is an encrypted one

        These attributes can be specified in constraints:

        ```yaml
        options:
          my_url:
            label: Site Address
            type: url
            constraints:
            - protocols: [http, https]
            constrains:
            - type: load-balancer
              service: lb
              attribute: protocol  # This picks out the 'http' or 'https' part of the URL
              setting: protocol
            - type: compute
              service: web
              attribute: "private_key"  # This picks out the cert
              setting: ssl_certificate
            - type: compute
              service: web
              attribute: "intermediate_key"  # This picks up the intermediate cert
              setting: ssl_intermediate_certificate
        ```

        You can constrain a list of protocols using the `protocols` constraint.

        ```yaml
        options:
          my_url:
            label: Site Address
            type: url
            constraints:
            - protocols: [http, https]
        ```

        And there are special display-hints used to aid a client in rendering and
        validating the url. These are `encrypted-protocols` and
        `always-accept-certificates` which are documented in constraints.

        When supplying the value for a url as an input, it can be supplied as a string
        or as a mapping with attributes.

        As a string it would be `my_site_address: https://mydomain.com/blog`.

        As a mapping:

        ```yaml
        inputs:
          my_url:
            url: https://domain.com/path
            private_key: |
              -----BEGIN...
            intermediate_key: |
              -----BEGIN...
            certificate: |
              -----BEGIN...
        ```

        Note:  A common use case is to supply the url and keys. A shortcut is available
        that accepts a key called `url` that can be used to supply the url without having
        to provide all the components of the url.

    display_name:
    constraints:
      type: list(constraint)
    resources:
      type: dict(resource)
      docs: |
        Static resources to be created and shared across the Checkmatefile. For
        example: users, passwords, or SSH keys:

        ```yaml
        resources:
          django_admin:
            type: user
            constrains:
              - setting: django_admin_user
              service: appserver
              resource_type: application
              attribute: name
              - setting: django_admin_pass
              service: appserver
              resource_type: application
              attribute: password
        ```

environment:
  docs: |
    An environment describes a group of providers which determine where a deployment's
    resources are hosted.

    An environment is also part of a Checkmatefile, and is defined under the
    top-level key `environment`.
  fields:
    id:
    name:
    providers:
      type: dict(provider)

deployment:
  docs: |
    A deployment is a launched instance of a [blueprint](#blueprint) in a given
    [environment](#environment). In other words, a deployment is an actual
    instance of a running application.

    A deployment will often also use the information under [inputs](#inputs) in the
    Checkmatefile, which supplies input values for blueprint [options](#options)
    (e.g., region, flavor, server count, etc.).

  fields:
    id:
      type: string  # not necessarily a UUID
      description: "A unique string to store, lookup and manipulate a deployment"
      docs: |
        A unique identifier (not necessarily a UUID, but a string. Although using
        a UUID is common, simple, and safe, it is not a friendly value for users to
        use.

        This value is also expected to be used in REST API URLs, so should be
        compatible with them. Therefore, the use of characters like colons or
        slashes is disallowed.
      validation_rules:
      - max_length: 32
        min_length: 6
        message: length must be between 6 and 32 characters
      - allowed_characters: |
          abcdefghijklmnopqrstuvwxyz
          ABCDEFGHIJKLMNOPQRSTUVWXYZ
          0123456789-_.+~@
      - allowed_start_chars: |
          abcdefghijklmnopqrstuvwxyz
          ABCDEFGHIJKLMNOPQRSTUVWXYZ
          0123456789
    name:
    blueprint:
    inputs:
      type: inputs

service:
  docs: |
    Services are the boxes on your virtual whiteboard and how they relate to each
    other. A catalog of all available services (and their default options) is
    available
    [here](https://github.com/checkmate/checkmate/blob/master/ui/rook/static/scripts/common/services/catalog.yml).

  fields:
    component:
      type: selector
    count:
      type: int
      description: the number of resources to add to this service
    relations:
      type: list(relation)
    constraints:
      type: list(constraint)

inputs:
  docs: |
    Inputs provide arguments for blueprint [options](#options). They can also
    override any part of the deployment configuration. (For example, it is possible
    to supply a provider override to create resources only in a specific region.)

    Inputs are defined in the top-level `inputs` key of a Checkmatefile.

    When launching a deployment, the values selected for options are stored as an
    *input* to the deployment under the 'inputs' key. Inputs can be applied at
    multiple levels in the deployment hierarchy as follows:

    **Global inputs (apply to everything):**

    ```yaml
    inputs:
      domain: mydomain.com
    ```

    **Blueprint inputs (apply to a setting on the blueprint):**

    ```yaml
    inputs:
      blueprint:
        domain: mydomain.com
    ```

    **Service inputs (apply to a particular service in the blueprint):**

    ```yaml
    inputs:
      services:
        "backend":
          use_encryption: true
    ```

    **Provider inputs (apply to a provider and any resourcers that
      provider provides):**

    ```yaml
    inputs:
      providers:
        'legacy':
          region: dallas
    ```

    **Resource type inputs. These can be applied under services or
    providers as follows:**

    ```yaml
    inputs:
      services:
      "backend":
        'database':
          'memory': 512 Mb
      providers:
        'nova':
          'compute':
            'operating-system': Ubuntu 12.04 LTS
    ```

    **Custom Resources inputs. These can be applied under
    `custom_resources` to describe an array of existing resources (e.g.
      when importing existing servers into Checkmate):**

    ```yaml
    inputs:
      custom_resources:
      - example_resource1:
        type: server
        provider: nova
        status: ACTIVE
        instance:
          id: 2098383
          private_ip: 10.10.1.1
          public_ip: 2.2.2.18
          flavor: 1
          image: 119
          dns-name: srv1.stabletransit.com
      - example_resource2:
        type: database
    ```
  fields:
    blueprint:
    services:
    providers:
    custom_resources:
      type: dict(resource)

option:
  fields:
    name:
    label:
    display_hints:
    type:
    constraints:
      type: list(constraint)
    constrains:

source:
  fields:
    repo_url:
    sha:
    ref:

checkmateFile:
  fields:
    blueprint:
      type: blueprint
    environment:
      type: environment
    inputs:
      type: inputs
    flavors:
      type: dict(checkmateFile)
    include:

relation:
  fields:
    service:
      type: service

    interface:
      type: interface

    connect_from:
      type: string
    connect_to:
      type: string
    constraints:
      type: list(constraint)
    attributes:
      type: list(attribute)
  shorthand: "<service>: <interface>[#<connect_from>]"

attribute:
  fields:

constraint:
  docs: |
    A constraint is used to restrict the range of valid choices for a setting.
    A constraint can be supplied in two formats; long form and shorthand. The
    shorthand format exists to simplify writing blueprints by support simple
    `setting: value` entries such as `os: Ubuntu 14.04`.

    The long form requires explicit key/value pairs in the format:
      setting: <name>
      <condition>: <value>
      message: <optional error message>
    In YAML, this would look like:
      constraints:
      - setting: os
        value: Ubuntu 14.04
        message: This app only works on Ubuntu 14.04!
      - setting: memory
        greater-than-or-equal-to: 1Gb
        Supported conditions are:

    * `greater-than`: self-explanatory (for strings or integers)
    * `less-than`: self-explanatory (for strings or integers)
    * `greater-than-or-equal-to`: self-explanatory (for strings or integers)
    * `less-than-or-equal-to`: self-explanatory (for strings or integers)
    * `min-length`: for strings or text
    * `max-length`: for strings or text (including URLs)
    * `allowed-chars`: for strings and text types. Ex. "ABCDEFGabcdefg012345657!&@"
    * `required-chars`: for strings and text types. Ex. "ABCDEFG"
    * `in`: a list of acceptable values (these could also be used by clients to
      display drop-downs)
    * `protocols`: unique to URL types. This lists allowed protocols in the URL.
      See also display-hints for `encrypted-protocols`
    * `regex`: do not use look-forward/behind. Keep these simple so they are
      supported in javascript (client) and python (server). While many of the above
      can also be written as regex rules, both are available to blueprint authors
      to use the one that suits them best.
    * `check`: evaluates a constraint using constructs like "if", "if-not",
      "and", etc...
  fields:
    setting:
    value:
    message:
    provider:
    greater_then:
    greater_than_or_equal_to:
    less_then:
    less_than_or_equal_to:
    allowed_chars:
    allowed_start_chars:
    in:
    protocols:
    regex:
    min_length:
    max_length:
  shorthand: "<setting>: <value>"

selector:
  fields:
    id:
    name:
    interface:
    resource_type:
    role:
    constraints:
      type: list(constraints)

resource:
  docs: |
    A resource is a generic primitive component for building application
    deployments. Some examples of resources include:

    * application
    * database
    * load-balancer
    * compute (a server of some type)
    * user (for example: an LDAP record for a user or database username/password)
    * keypair

    Different providers may provide slightly different but equivalent variations
    of a given type of resource. For example for a "compute" node, a Cloud Server
    hosted by Rackspace and an EC2 instance hosted by Amazon can both satisfy a
    requirement for `compute: ssh`.
  fields:
    index:
    component:
    type:
    desired_state:
    instance:
    status:
    provider:
    hosts:
    hosted_on:

provider:
  docs: |
    A provider is a code module that wraps a single vendor's API and provides a
    generic interface to manage [resources](#resource).

    A provider has a catalog that lists the types of resources that it can provide.
  fields:
    catalog:
      type: catalog
    constraints:
      type: list(constraint)

catalog:
  type: dict(component)

component:
  docs: |
      GET /providers
      GET /:tenant_id/environments/:id/providers/:id/catalog/
      - you'll get a list of components grouped by resource type. (You'll also get some additional info called lists).
  fields:
    id:
      type: string  # not necessarily a UUID
      description: |
        a unique identifier (not necessarily a UUID, but a string... although that
        is common, safe, and ... the ugly option) within the
        provider that provides that component.

        Note: `name` was used for this field in an earlier version of Checkmate

    name:
      type: string
      description: |
        A globally unique and known, predefined name. For example, the name for
        wordpress is wordpress always (in puppet, chef, etc....). And we will maintain
        a list of those names (at least for now). Precedents for this are OpsCode cookbooks and Juju charms
        (http://jujucharms.com/charms/precise).
        **Action item/future consideration** create our own catalog (or use Charms/cookbooks)

    display_name:
      type: string
      description: For user friendliness (*mssql vs Microsoft SQL Server)

    role:
      type: string
      description: |
        Allows you to specify the role of this component.

        Example:

        > component:
        >   name: wordpress
        >   role: master

    version:
      description: supply a version string in semantic versioning format.

    description: |
      A short description of the component.

    is:
      description: |
        describes the type of resource based on a list of primitive resource types (compute, database, load-balancer, application, ...)
        starting with ones from OpenStack.

    requires:
      description: |
        what this resource needs. The needs can be specific or general. General would be anything with a mysql
        interface (for WordPress). Specific examples would be:I need a host compute resource that is an Ubuntu 12.04 or
        later machine. Or I need a mysql database that is on a Rackspace Cloud Database instance.

        Syntax (two options, long an short form):
            type: interface. Example: database: mysql - short syntax is resource_type:interface. By design.
            name: hash (key/value pairs) for more specific stuff. Name is arbitrary.
            Name key/value example:
                server: (this is the arbitrary key - the label of this requirement)
                    type: compute
                    interface: debian (this says I expect to be able to do apt-get, vs yum)
                    relation: host (this says I am hosted on this resource. I cannot exist without it. I am down when it is
                              down). "host" is a keyword.
                    constraint:
                    - 'os': ['debian', 'redhat']
        The name+key/value syntax allows for requiring more than one of the same resource (ex. log and data mysql databases)
        as well as adding additional constraints, etc....

    provides:
      description: |
        array of resource_type:interface entries (array can be represented in YAML with entries preceded with
        dashes). For example, let's say we get a Cloud Sites API that provides a "site" resource. Site could provide:
        - database: mysql
        - application: php

    supports:
      description: |
        other services or components that this component can use (ex. optional cache)

    options:
      description: |
        What settings I can set on this component

        ```
        username:
            default: root
            required: optional | required | auto-generated (default: optional)
            type: string (currently we support string, int, boolean) (default: string)
                * Action Items: How can we tie this to a "list" from the provider
            label: User Name (used for display friendliness)
            description: ...
            source_field_name: the name as it is known by the underlying provider. Ex. wordpress/database/db_user for OpsCode
                               Chef. We need this currently since we dynamically generate component definitions and we need
                               to be able to map things back after they've flowed through checkmate.
                * Should be able to get rid of this in the future with clean, reversible mapping logic in providers.
            type: string
            regex: for validation
            sample: for display, to show what this looks like.
            help: help text.
        password:
        ```

display_output:
  docs: |
    Display outputs is how a Checkmatefile author determines what information to
    provide to the end user to be able to use the deployment (credentials, urls,
    etc).

    Display outputs can be specified in three ways:

    1 - under a component in blueprint services

    ```yaml
    service:
        database:
        component:
          display-outputs:
            "Password":
              label:"blah"
              order: 1
              source: mysql://passwd
    ```

    2 - in a blueprint option by setting `display-output` to the boolean value
    `true`.

    ```yaml
    options:
        "AdminUser":
           display-output: true
    ```

    3 - as a map under blueprint

    ```yaml

    blueprint:
      display-outputs:
        "Site Address":
          type: url
          source: options://url
          extra-sources:
            ipv4: "resources://instance/vip?resource.service=lb&type=resource.load-balancer"
          order: 1
          group: application
        "Admin Username":
          type: string
          source: options://username
          order: 2
          group: application
        "Admin Password":
          type: password
          source: options://password
          order: 3
          group: application
        "Private Key":
          type: private-key
          source: "resources://instance/private_key?resource.index=deployment-keys"
          order: 4
          group: application
        "Database Username":
          source: options://db_username
          order: 5
          group: database
        "Database Password":
          type: password
          source: options://db_password
          order: 6
          group: database
        "Database Host":
          source: "resources://instance/interfaces/mysql/host?resource.service=db&resource.type=compute"
          order: 7
          group: database
    ```

    ###### Syntax for Display Outputs

    The syntax is:

    ```
    {root}://{path}

    root = "options" | "resources" | "services"
    path = [/keys]/result (ends with value to return)
    ```

    Examples:

    ```
    # Get the value of the 'url' option
    source: options://url

    # Get the private_key of the 'url' option
    source: options://url/private_key

    # Get the private_key of the deployment keys
    source: "resources://deployment-keys/instance/private_key"

    # Get the database password
    source: "services://db/interfaces/mysql/database_password"
    ```

    ```yaml
    # under deployment
    display-outputs:
      Site Address:
        type: url
        uri: http://example.com/
        extra-info:
          ipv4: 4.4.4.204
        order: 1
        group: application
      Admin Username:
        type: string
        value: john
        order: 2
        group: application
      Admin Password:
        type: password
        value: w34ot8how87h34t
        order: 3
        group: application
      Private Key:
        type: private-key
        value: |
          -----BEGIN RSA PRIVATE KEY-----
          MIIEpAIBAAKCAQEAu1R+vwvUR3o5rQa6ny79OlhLT2qWYY0xKVg5bxW0DGKhn/6e
          gI8yWSf9kUmbEWdO1xuQiEiMnAA2wY0w+TXHCNkCX305shCGL/ejt4XrPLloK7c6
          anCS2MTdcDUjppeHhhNi7TdotN9E5wxY8x1IBtioCldNVIkJVwZMhiMORteGpOZ2
          DV+OZ2GquZKrrrRN9tJtIwMMbqjVno1k3Lz3iJfvRZn4D5xZFSd/lgTp+H0bpc4o
          9kS9Z4k44l9chMvZItGjAgwQ07ORny5cPnKCAPewO+F20ng+WT19KerGWQq/58T3
          -----END RSA PRIVATE KEY-----
        order: 4
        group: application
    ```

workflow:
  docs: |
    A workflow consists of a collection of actions being applied to a deployment or
    its resources. Workflows are generated to create, delete, or modify deployments.
    Only one workflow may run per deployment at a given time.

    Typical workflows are:

    * deploy
    * scale up
    * scale down
    * bring node online
    * take node offline
    * delete (deployment)

    Workflow is often used synonymously with "operation".

